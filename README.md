Конечно! Вот ваш текст, отформатированный с использованием Markdown-разметки:

---

# DragNDropTestCase

Данное тестовое задание выполнено с учетом следующих пунктов:

1. Предметы можно перетаскивать по 2D сцене (задний фон).
2. При отпускании предметы должны падать вниз под действием гравитации.
3. Реализовать возможность ставить предметы на полки с учетом глубины сцены (чтобы можно было ставить ближе или дальже).

**ОПЦИОНАЛЬНО**

4. Реализовать скроллинг сцены для перемещения по комнате.

## Zenject

### Основные моменты

При помощи Zenject в контейнер инъектятся два класса: `InputHandler` и `TouchInput`.

## Описание основных сущностей

### InputHandler и TouchInput

`InputHandler` - логический класс, создается в единственном экземпляре и в целом он не нужен никому в качестве зависимости, но ему нужен `TouchInput`, а точнее любой класс, реализующий интерфейс `IInput`.

`IInput` - данный интерфейс содержит в себе 4 события:

- `public event Action<Vector2> OnClickDown;`
- `public event Action<Vector2> OnClickUp;`
- `public event Action<Vector2> OnMovedToPosition;`
- `public event Action<Vector2> OnMovedToDirection;`

Каждое из которых срабатывает в определенный момент времени при взаимодействии пользователя с дисплеем. Для отслеживания взаимодействия с дисплеем создана прозрачная панель, на которой в качестве компонента "висит" `TouchInput`, реализующий следующие интерфейсы:

- `IInput`
- `IPointerDownHandler`
- `IBeginDragHandler`
- `IDragHandler`
- `IEndDragHandler`
- `IPointerMoveHandler`

Каждый из этих интерфейсов, кроме `IInput`, отслеживает определенные этапы взаимодействия пользователя с UI. Детали реализации можно увидеть в коде.

`InputHandler` подписывается на каждое из этих событий и в зависимости от текущего состояния принимает решение касательно того, что должно происходить.

К примеру, если приходит событие `OnClickDown`, то тогда происходит рейкаст в получаемых координатах (координаты преобразуются из UI-ных в мировые в `TouchInput`), и если рейкаст проходит по объекту с компонентом, реализующему интерфейс `IDraggable`, то тогда ссылка на него кэшируется. При получении информации о событии `OnMovedToPosition`, закэшированный объект `IDraggable` перемещается за курсором/пальцем в передаваемые координаты.

Также `InputHandler` отслеживает событие перемещения камеры по событию `OnMovedToDirection`, но если на данный момент `IDraggable` не равен `null`, то перемещение камеры не последует. Также `InputHandler` проверяет, не выходим ли мы за пределы фона (это нарушение SRP, так как лучше эту работу предоставить какому-нибудь сервису, к которому мы сможем получить доступ через интерфейс, но я решил сделать так, чтобы не писать ещё больше текста, извините).

Все объекты, которые пользователь может перетаскивать, реализуют интерфейс `IDraggable`:

```csharp
public interface IDraggable
{
    void Drag(Vector2 direction);
    void Drop();
}
```

Методы `Drag` и `Drop` отвечают за процесс Drag'n'Drop. Данный интерфейс реализует один класс `DraggableObject`.

`DraggableObject` - это компонент `MonoBehaviour`, который реализует также интерфейс `ILockable`, который отвечает за то, что объект находится в движении или же закреплен за своей позицией. Движение объекта реализовано через компонент `Rigidbody2D` с включенным свойством `isKinematic`.

Если объект не заблокирован и не перетаскивается, то тогда в `FixedUpdate` идет проверка - по корректному ли пути идет текущий объект. Если да, то тогда объект движется вниз, если нет, то тогда один раз метод поиска и перемещения к ближайшей точке стыкуемого пола. В методе поиска и перемещения к ближайшей точке сначала происходит не аллоцируемый каст окружности по заданным полями параметрам, затем в первый существующий коллайдер направляется луч, точка пересечения которых затем отдается корутине в качестве параметра.

В корутине объект просто перемещается до тех пор, пока расстояние между двумя точками не станет `MIN_DISTANCE_TO_NEAREST_POINT` (магические числа - это плохо, поэтому используется константа). После перемещения к точке объект полностью стыкуется с полом и выставляются флаги, которые позволят в дальнейшем работе `FixedUpdate` работать как и описано было выше.

# ЧТО МОЖНО УЛУЧШИТЬ!?

1. **Сделать так, чтобы можно было перемещать несколько объектов, как в референсе:**
   - **Как:** Передавать не только координаты, но и ID пальцев, касающихся дисплея, а также в `InputHandler` создать не просто ссылку на текущий объект, а целую коллекцию, где ID - это ID пальца, а содержимое по индексу - ссылка на объект. Если ссылка `null`, то тогда двигать камеру в ту сторону, куда этот палец и ведет.

2. **Сделать перемещение объектом по краю экрана:**
   - **Как:** Проверять, находится ли данный палец/курсор с объектом близко к краю экрана и двигать камеру в ту или иную сторону в зависимости от направления движения относительно центра камеры в мировых координатах.

3. **Улучшить алгоритм расчета того, что объект не "летит" за экран:**
   - **Как:** К сожалению, я долго возился с этим вопросом, и пока что то решение, что я сделал на данный момент, лучшее, что я мог придумать, но у меня есть пара идей.

---

Если у вас есть дополнительные вопросы или нужна помощь с другими аспектами форматирования, дайте знать!
