# DragNDropTestCase
Данное тестовое задание выполнено с учетом следующих пунктов:

1) Предметы можно перетаскивать по 2D сцене (задний фон)
2) При отпускании предметы должны падать вниз под действием гравитации.
3) Реализовать возможность ставить предметы на полки с учётом глубины сцены (чтобы можно было ставить ближе или дальше).

ОПЦИОНАЛЬНО

4)Реализовать скроллинг сцены для перемещения по комнате.

Основные моменты
При помощи ZENJECT в контейнер инъектятся два класса InputHandler и TouchInput.
InputHandler - логический класс, создаётся в единственном экземпляре и в целом он не нужен никому в качестве зависимости, но ему нужен TouchInput,а точнее любой класс, реализующий интерфейс IInput.

IInput - данный интерфейс содержит в себе 4 события
        public event Action<Vector2> OnClickDown;
        public event Action<Vector2> OnClickUp;
        public event Action<Vector2> OnMovedToPosition;
        public event Action<Vector2> OnMovedToDirection;
Каждое из которых срабатывает в определенный момент времени при взаимодействии пользователя с дисплеем. Для отслеживания взаимодействия с дисплеем создана прозрачная панель, на которой в кач-ве компонента "висит" TouchInput, реализующий следующие интерфейсы:
        , IInput
        , IPointerDownHandler
        , IBeginDragHandler
        , IDragHandler
        , IEndDragHandler
        , IPointerMoveHandler
Каждый из этих интерфейсов, кроме IInput, отслеживает определенные этапы взаимодействия пользователя с UI, детали реализации можно увидеть в коде.
InputHandler подписывается на каждое из этих событий и в зависимости от текущего состояния принимает решение касательно того, что должно происходить.
К примеру, если приходит событие OnClickDown, то тогда происходит рейкаст в получаемых координатах (координаты преобразуются из UI-ных в мировые в TouchInput) и если рейкаст проходит по объекту с компонентом, реализующем интерфейс IDraggable, то тогда ссылка на него кэшируется и при получении информации о событие OnMovedToPosition, закэшированный объект IDraggable перемещается за курсором/пальцем в передаваемые координаты.
Также InputHandler отслеживает событие перемещения камеры по событию OnMovedToDirection, но если на данный момент IDraggable не равен null, то перемещение камеры не последует. а также InputHandler проверяет не выходим-ли мы за пределы фона (Это нашруние SRP, т.к. лучше эту работу предоставить какому-нибудь сервису, к которому мы сможем получить доступ через интефейс, но я решил сделать так, чтобы не писать ещё больше текста, извините). 

Все объекты, которые пользователь может перетаскивать реализуют интерфейс IDraggable:
 public interface IDraggable
    {
        void Drag(Vector2 direction);
        void Drop();
    }
Методы Drag и Drop отвечают за, собственно говоря, процесс Drag'n'Drop-а. Данный интерфейс реализует один класс DraggableObject. 
DraggableObject - это компонент Monobehaviour, который реализует также интерфейс ILockable, который отвечает за то, что объект находится в движении или же закреплен за своей позицией. Движение объекта реализовано через компонент Rigidbody2D с включенным свойство isKinematic. Если объект не заблокирован и не перетаскивается, то тогда в FixedUpdate идет проверка - по корректному-ли пути идет текущий объект, если да, то тогда объект движется вниз, если нет, то тогда один раз метод поиска и перемещения к ближайшей точки стыкуемого пола. В методе поиска и перемещения к ближайшей точке сначала происходит не аллоцируемый каст окружности по заданным полями параметрам, затем в первый существующий коллайдер направляется луч, точка пересечения которых затем отдается корутине в кач-ве параметра. В корутине объект просто перемещается до тех пор, пока расстояние между двумя точками не станет MIN_DISTANCE_TO_NEAREST_POINT (магические числа - это плохо,потому используется константа), после перемещения к точке объект полностью стыкуется с полом и выставляются флаги, которые позволят в дальнейшем работе FixedUpdate работать как и описано было выше.  


ЧТО МОЖНО УЛУЧШИТЬ!?

Сделать так, чтобы можно было перемещать несколько объектов, как в референсе:
КАК: передавать не только координаты, но id пальцев, касающихая дисплея, а также в InputHandler создать не просто ссылку на текущий объект, а целую коллекцию, где id - это ID пальца, а содержимое по индексу - ссылка на объект, если ссылка null, то тогда двигать камеру в ту сторону, куда этот палец и ведет.

Сделать перемещение объектом по краю экрана: проверять находится ли данный палец/курсор с объектом близко к краю экрана и двигать камеру в ту или иную сторону в зависимости от направления движения относительно центра камеры в мировых координатах.

Улучшить алгоритм расчета того, что объект не "летит" за экран
Как: к сожалению, я долго возился с этим вопросом, и пока что то решение, что я сделал на данный момент, лучшее, что я мог придумать, но у меня есть пара идей.
